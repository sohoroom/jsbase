/*
位元運算符用於直接對二進制位進行計算操作，一共有七：(位元邏輯閘運算)
與(and)運算：符號為(&)，若兩個二進制位元都為1，則結果為1，否則為0。
或(or)運算：符號為(|)，若兩個二進制位元都為0，則結果為0，否則為1。(或說有一個為1則為1)
否(not)運算：符號為(~)，表示對一個二進制位元取反。
異或(xor)運算：符號為(^)，表示二進制位不同結果為1，其餘為0(即11為0、00為0)。
左移(left shift)運算：符號為(<<)，見下。
右移(right shift)運算：符號為(>>)，見下。
頭部補零的右移(zero filled right shift)運算：符號為(>>>)，見下。
*/
//位元運算只對整數作用，JS中數值以64位浮點數形式儲存，於位元運算時是以
//32位帶符號的整數進行運算，返回值亦為32位帶符號的整數。
var i = 4566789.4566789
i = i | 0;  //將i轉化為帶符的32位整數
function toInt32(x){
  return x | 0;
}  //大於或等於2的32次方之整數，其大於32位元的數位會被捨去
toInt32(Math.pow(2,32)-1)  //-1
toInt32(Math.pow(2,32)+1)  //1
//And(&)
0 & 7  //0
2 & 7  //2
-2 & 7.99  //6，☆
//Or(|)
0 | 7  //7
2 | 7  //7
2 | 7.99  //7
-2 | 7.99  //-1，☆

//Not(~)，位元運算以32位元帶符號整數進行運算☆
~3  //-4
//3的32位二進制0000 0000 0000 0000 0000 0000 0000 0011
//取反         1111 1111 1111 1111 1111 1111 1111 1100，首碼為1代表為"負數"(-)
//JS補碼表負(1)1111 1111 1111 1111 1111 1111 1111 1011，即取反減1
//JS補碼表負(2)0000 0000 0000 0000 0000 0000 0000 0100，二次取反得"值"(4)
//簡單記憶法：一個數與自身的取反值相加等於(-1)，一個數兩次取反等於自身(取整數)
~~2.9  //2
~~-47.11  //-47
~~1.6666  //1
~~-99.99  //-99
//連續兩次Not(~)運算，有快速的取整的效果
//對字串符進行Not(~)運算，JS引擎會先調用Number()將其轉為數值，再進行Not(~)運算
~'011'  //-12，同~Number('011')
~'42 cats'  //-1，同~Number('42 cats')
~'0xcafebabe'  //889275713，同~Number('0xcafebabe')
~'deadbeef'  //-1，同~Number('deadbeef')
~[]  //-1，同~Number([])
~NaN  //-1，同~Number(NaN)
~null  //-1，同~Number(null)

//Xor(^)異或運算在二進制位不同時反回1，相同時則返回0。
0 ^ 3 //3，Bit:00 ^ 11
//透過連三異或(Xor)，互換兩數值型變數
var a = 99;
var b = 100;
a ^= b, b ^= a, a ^= b;  //不透過中間變數，互換兩數值型變數
console.log('a =', a);  //a = 100
console.log('b =', b);  //b = 99
//異或Xor(^ 0)取整
12.999 ^ 0;  //12
-12.99 ^ 0;  //-12
-24.55555 ^ 0;  //-24
24.555555 ^ 0;  //24

//左移運算符(<<)表示將一個數的二進制值向左移動指定的位數，而在其尾部補0。
//即乘以2之指定次方，向左移動時，最高位的符號位(正負號)是一起移動的。
//4，Bit：100
4 << 1;  //8，Bit：1000
//-4，Bit：1111 1111 1111 1111 1111 1111 1111 1100
-4 << 1;  //-8
-13.55 << 0;  //-13，向左移0位，相當於轉換為32位元整數，為相當方便的取整

//使用左移運算符(<<)，RGB to HEX
var color = {r: 186, g: 218, b: 85};
// (1 << 24)的作用為保證結果是6位數
var rgb2hex = function(r, g, b) {
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)
    .toString(16) // 先轉成十六進制，然後返回字符串
    .substr(1);   // 去除字符串的最高位，返回後面的六個字符串
}
rgb2hex(color.r, color.g, color.b)  //"#bada55"

//右移運算符(>>)表示將一個數的二進制值向右移動指定的位數。
//若原為正數，頭部全部補0；若原為負數，頭部全部補1。
//右移運算即為除以2的指定次方，最高位的符號位(正負號)亦為一起移動的。
4 >> 1;  //2，相當於4/2
8 >> 2;  //2，相當於8/4
-16 >> 3;  //-2，相當於-16/8
-16 >> 0;  //-16，相當於-16/1

//頭部補零的右移運算符(>>>)，其與右移運算符(>>)只有一個差別，就是一個數的二進制
//向右移動時，頭部一律補零，不考慮頭部符號位(正負號)，故該運算總是得到正值。正數
//之(>>>)與(>>)運算完全一致，區別只在於負數。此運算即為將值轉為32位無符號整數。
4 >>> 1;  //2，相當於4/2
8 >>> 2;  //2，相當於8/4
-16 >>> 0;  //4294967280，查看負整數在計算機內部儲存形式，即可使用此運算符(>>> 0)
-1 >>> 0;  //4294967295，-1即為(2^32)-1於內部儲存
           //(-1)_Bit of 32:1111 1111 1111 1111 1111 1111 1111 1111

//開關作用，位元運算符可以用來設置對象屬性的開關
//假定某對象有四個開關，每個開關皆為一個變量：
var FLAG_A = 1;  // 0001
var FLAG_B = 2;  // 0010
var FLAG_C = 4;  // 0100
var FLAG_D = 8;  // 1000
//使用位元運算符檢查開關是否打開
var flags = 5;  // 0101
flags & FLAG_A;  //1，0001
flags & FLAG_B;  //0，0000
flags & FLAG_C;  //4，0100
flags & FLAG_D;  //0，0000

//以掩碼(mask)打開開關
//假設現在要打開A、B、C三個開關，我們需使用或or(|)建構一個掩碼變量(mask)
var mask = FLAG_A | FLAG_B | FLAG_C;  //0001 | 0010 | 0100 => 0111
flags = flags | mask;  // 0101 | 0111 => 0111
//關畢與掩碼變量(mask)不同的開關，使用與and(&)
var mask = FLAG_A | FLAG_D;  //1001，掩碼預計關畢BC兩個開關
flags = flags & mask;  // 0111 & 1001 => 0001
//異或xor(^)可切換(toggle)當前設置(mask若為1111全開時，即開變關、關變開)
flags = flags ^ mask;  // 8，0001 ^ 1001 => 1000
flags = flags ^ mask;  // 1，1000 ^ 1001 => 0001
var mask = FLAG_A | FLAG_B | FLAG_C | FLAG_D;  //1111
flags = flags ^ mask;  //14，0001 ^ 1111 => 1110
flags = flags ^ mask;  //1，1110 ^ 1111 => 0001
//